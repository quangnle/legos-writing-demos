<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q-Learning - Simple Robot Path finding</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 12px;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background: #333;
            color: #fff;
            padding-top: 10px;
            min-height: 40px;
            border-bottom: #333 solid 3px;
        }
        header h1 {
            margin: 0;
            padding: 0;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
        }   
    </style>
</head>
<body>
    <header>
        <h1>Q-Learning - Simple Robot Path finding</h1>
    </header>
    <div class="container">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.js"></script>
        <script>
            // M√¥ ph·ªèng Q-Learning tr√™n l∆∞·ªõi 5x5 s·ª≠ d·ª•ng p5.js
// Robot h·ªçc c√°ch t√¨m ƒë∆∞·ªùng ƒë·∫øn ƒë√≠ch, tr√°nh ch∆∞·ªõng ng·∫°i v·∫≠t qua th·ª≠-sai

const cols = 5, rows = 5; // K√≠ch th∆∞·ªõc l∆∞·ªõi 5x5
const cellSize = 100;     // K√≠ch th∆∞·ªõc m·ªói √¥ vu√¥ng
let qTable = {};          // B·∫£ng Q-table: l∆∞u gi√° tr·ªã h√†nh ƒë·ªông ·ªü m·ªói tr·∫°ng th√°i
let robot, goal;          // V·ªã tr√≠ c·ªßa robot (agent) v√† ƒë√≠ch (goal)

// T·ªça ƒë·ªô c√°c √¥ ch∆∞·ªõng ng·∫°i v·∫≠t (X)
let bombs = [[0,2], [1,1], [1,3], [2,3], [3,0], [3,1], [4,3]]; // C√°c √¥ bomb ƒë∆∞·ª£c ƒë·∫∑t t·∫°i c√°c t·ªça ƒë·ªô n√†y

let actions = ['up', 'down', 'left', 'right']; // C√°c h√†nh ƒë·ªông c√≥ th·ªÉ th·ª±c hi·ªán

let episodeReward = 0; // T·ªïng ph·∫ßn th∆∞·ªüng trong m·ªôt v√≤ng h·ªçc
let episode = 0;        // S·ªë v√≤ng h·ªçc ƒë√£ ch·∫°y

// C√°c tham s·ªë Q-Learning
let alpha = 0.1;   // learning rate: t·ªëc ƒë·ªô c·∫≠p nh·∫≠t
let gamma = 0.9;   // discount factor: ƒë·ªô quan t√¢m ƒë·∫øn ph·∫ßn th∆∞·ªüng t∆∞∆°ng lai
let epsilon = 0.1; // x√°c su·∫•t ch·ªçn h√†nh ƒë·ªông ng·∫´u nhi√™n (thƒÉm d√≤)
let success = 0; // s·ªë l·∫ßn th√†nh c√¥ng t√¨m ƒë∆∞·ªùng ƒë·∫øn ƒë√≠ch
let failure = 0; // s·ªë l·∫ßn th·∫•t b·∫°i (va v√†o ch∆∞·ªõng ng·∫°i v·∫≠t)

function setup() {
    createCanvas(cols * cellSize, rows * cellSize);
    frameRate(5 ); // T·ªëc ƒë·ªô c·∫≠p nh·∫≠t
    resetRobot();  // Kh·ªüi t·∫°o l·∫°i robot
    goal = [4,4];  // M·ª•c ti√™u ƒë·∫∑t t·∫°i √¥ (4,4)
}

function draw() {
    background(240);
    drawGrid();       // V·∫Ω l∆∞·ªõi
    drawBombs();  // V·∫Ω ch∆∞·ªõng ng·∫°i v·∫≠t
    drawRobot();      // V·∫Ω robot
    drawGoal();       // V·∫Ω ƒë√≠ch ƒë·∫øn

    let state = robot.join(','); // Chuy·ªÉn tr·∫°ng th√°i v·ªÅ d·∫°ng chu·ªói 'x,y'
    if (!qTable[state]) qTable[state] = Array(actions.length).fill(0); // Kh·ªüi t·∫°o n·∫øu ch∆∞a c√≥

    let actionIndex = chooseAction(state); // Ch·ªçn h√†nh ƒë·ªông theo epsilon-greedy
    let action = actions[actionIndex];     // L·∫•y t√™n h√†nh ƒë·ªông t·ª´ ch·ªâ s·ªë
    let [nextX, nextY] = getNextPos(robot, action); // T√≠nh to√°n v·ªã tr√≠ ti·∫øp theo

    let reward = getReward(nextX, nextY); // T√≠nh ph·∫ßn th∆∞·ªüng nh·∫≠n ƒë∆∞·ª£c
    episodeReward += reward;              // C·ªông d·ªìn ph·∫ßn th∆∞·ªüng cho t·∫≠p hi·ªán t·∫°i

    let nextState = [nextX, nextY].join(','); // Tr·∫°ng th√°i k·∫ø ti·∫øp
    if (!qTable[nextState]) qTable[nextState] = Array(actions.length).fill(0); // Kh·ªüi t·∫°o n·∫øu c·∫ßn

    // C·∫≠p nh·∫≠t Q-table theo c√¥ng th·ª©c Q-Learning
    // Q(s, a) = Q(s, a) + Œ± * (r + Œ≥ * max(Q(s', a')) - Q(s, a))
    // Trong ƒë√≥: s l√† tr·∫°ng th√°i hi·ªán t·∫°i, a l√† h√†nh ƒë·ªông, r l√† ph·∫ßn th∆∞·ªüng, s' l√† tr·∫°ng th√°i ti·∫øp theo
    // Œ± l√† learning rate, Œ≥ l√† discount factor
    // max(Q(s', a')) l√† gi√° tr·ªã t·ªëi ƒëa c·ªßa Q-table t·∫°i tr·∫°ng th√°i ti·∫øp theo
    // Ch·ªçn h√†nh ƒë·ªông t·ªët nh·∫•t t·∫°i tr·∫°ng th√°i ti·∫øp theo    
    qTable[state][actionIndex] += alpha * (reward + gamma * Math.max(...qTable[nextState]) - qTable[state][actionIndex]);

    robot = [nextX, nextY]; // Di chuy·ªÉn robot sang tr·∫°ng th√°i m·ªõi

    // N·∫øu ƒë√£ ƒë·∫øn ƒë√≠ch ho·∫∑c ƒë·ª•ng ch∆∞·ªõng ng·∫°i, b·∫Øt ƒë·∫ßu t·∫≠p m·ªõi
    if (reward === 100 || reward === -10) {
        if (reward === 100) success++; // ƒê·∫øn ƒë√≠ch th√†nh c√¥ng
        else failure++;                // ƒê·ª•ng ch∆∞·ªõng ng·∫°i v·∫≠t
        
        episode++;
        resetRobot();
        episodeReward = 0;
    }

    displayStats(); // Hi·ªÉn th·ªã th·ªëng k√™: s·ªë v√≤ng h·ªçc, ƒëi·ªÉm
}

// ƒê∆∞a robot v·ªÅ v·ªã tr√≠ b·∫Øt ƒë·∫ßu
function resetRobot() {
    robot = [0, 0];
}

// Ch·ªçn h√†nh ƒë·ªông theo ch√≠nh s√°ch epsilon-greedy
function chooseAction(state) {
    if (random() < epsilon) {
        return floor(random(actions.length)); // Ch·ªçn ng·∫´u nhi√™n ƒë·ªÉ kh√°m ph√°
    }
    return qTable[state].indexOf(max(qTable[state])); // Ch·ªçn h√†nh ƒë·ªông t·ªët nh·∫•t
}

// T√≠nh v·ªã tr√≠ m·ªõi sau khi th·ª±c hi·ªán h√†nh ƒë·ªông
function getNextPos([x, y], action) {
    if (action === 'up') y--;
    if (action === 'down') y++;
    if (action === 'left') x--;
    if (action === 'right') x++;
    // ƒê·∫£m b·∫£o kh√¥ng ra kh·ªèi l∆∞·ªõi
    x = constrain(x, 0, cols - 1);
    y = constrain(y, 0, rows - 1);
    return [x, y];
}

// Tr·∫£ v·ªÅ ph·∫ßn th∆∞·ªüng cho tr·∫°ng th√°i (x, y)
function getReward(x, y) {
    if (bombs.some(b => b[0] === x && b[1] === y)) return -10; // Va v√†o bomb
    if (x === goal[0] && y === goal[1]) return 100;                // ƒê·∫øn ƒë√≠ch
    return -1;                                                     // M·ªói b∆∞·ªõc ƒëi tr·ª´ 1
}

// V·∫Ω l∆∞·ªõi 5x5
function drawGrid() {
    stroke(180);
    textSize(10);
    textAlign(LEFT, TOP);    
    for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
            let px = x * cellSize;
            let py = y * cellSize;
            noFill();
            rect(px, py, cellSize, cellSize);

            // Hi·ªÉn th·ªã gi√° tr·ªã Q t·∫°i 4 g√≥c
            let stateKey = `${x},${y}`;
            if (qTable[stateKey]) {
                fill(0);
                textSize(9);
                text(`‚Üë${qTable[stateKey][0].toFixed(1)}`, px + cellSize/2 + 2, py + 2); // up
                text(`‚Üì${qTable[stateKey][1].toFixed(1)}`, px + cellSize/2 + 2, py + cellSize - 12); // down
                text(`‚Üê${qTable[stateKey][2].toFixed(1)}`, px + 2, py + cellSize / 2 - 6); // left
                text(`‚Üí${qTable[stateKey][3].toFixed(1)}`, px + cellSize - 26, py + cellSize / 2 - 6); // right
            }
        }
    }
}

// V·∫Ω c√°c √¥ bomb
function drawBombs() {
    fill(100);
    noStroke();
    for (let [x, y] of bombs) {
        textSize(20);
        textAlign(CENTER, CENTER);
        text("üí£", (x + 0.5) * cellSize, (y + 0.5) * cellSize);
    }
}

// V·∫Ω robot
function drawRobot() {
    fill(50, 150, 255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text("ü§ñ", robot[0] * cellSize + cellSize/2, robot[1] * cellSize + cellSize/2);
}

// V·∫Ω √¥ ƒë√≠ch
function drawGoal() {
    fill(50, 200, 50);
    textSize(20);
    textAlign(CENTER, CENTER);
    text("üè¥", (goal[0] + 0.5) * cellSize, (goal[1] + 0.5) * cellSize);
}

// Hi·ªÉn th·ªã s·ªë v√≤ng h·ªçc v√† t·ªïng ƒëi·ªÉm th∆∞·ªüng c·ªßa t·∫≠p hi·ªán t·∫°i
function displayStats() {
    fill(0);
    textSize(11);
    textAlign(LEFT, CENTER);    
    text(`Episode: ${episode}`, 10, height - 50);
    text(`Reward: ${episodeReward}`, 10, height - 35);
    text(`Failure: ${failure}`, 10, height - 20);
    text(`Success: ${success}`, 10, height - 5);
    
}
        </script>
    </div>    
</body>
</html>